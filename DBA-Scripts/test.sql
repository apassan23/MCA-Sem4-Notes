select * from links;


-- Insert rows and returns the rows just inserted
insert into links (url, name)
values ('https://binarysearch.com', 'BinarySearch'),
        ('https://jwt.io', 'JSON Web Tokens')
returning *;     


-- DELETE

DELETE FROM links;


-- UPSERT
DROP TABLE IF EXISTS customers;

CREATE TABLE customers (
	customer_id serial PRIMARY KEY,
	name VARCHAR UNIQUE,
	email VARCHAR NOT NULL,
	active bool NOT NULL DEFAULT TRUE
);

INSERT INTO 
    customers (name, email)
VALUES 
    ('IBM', 'contact@ibm.com'),
    ('Microsoft', 'contact@microsoft.com'),
    ('Intel', 'contact@intel.com');
    
    
    
INSERT INTO customers (name, email)
VALUES('Microsoft','hotline@microsoft.com') 
ON CONFLICT (name) 
DO 
   UPDATE SET email = EXCLUDED.email || ';' || customers.email;
   
   
   
-- TRANSACTIONS

DROP TABLE IF EXISTS accounts;

CREATE TABLE accounts (
    id INT GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL,
    balance DEC(15,2) NOT NULL,
    PRIMARY KEY(id)
);


INSERT INTO accounts(name,balance)
VALUES('Bob',10000);

INSERT INTO accounts(name,balance)
VALUES('Alice',10000);



-- start a transaction
BEGIN;

-- deduct 1000 from account 1
UPDATE accounts 
SET balance = balance - 1000
WHERE id = 1;

-- add 1000 to account 2
UPDATE accounts
SET balance = balance + 1000
WHERE id = 2; 

-- select the data from accounts
SELECT id, name, balance
FROM accounts;

-- commit the transaction
COMMIT;

INSERT INTO accounts(name, balance)
VALUES('Jack',0);    


-- begin the transaction
BEGIN;

-- deduct the amount from the account 1
UPDATE accounts 
SET balance = balance - 1500
WHERE id = 1;

-- add the amount from the account 3 (instead of 2)
UPDATE accounts
SET balance = balance + 1500
WHERE id = 3; 

-- roll back the transaction
ROLLBACK;



-- CASE EXPRESSIONS

select * from film 
order by title;

select film_id, title, length,(
CASE
    WHEN length <= 50 THEN 'SHORT'
    WHEN length > 50 and length <= 120 THEN 'MEDIUM'
    ELSE 'LONG'
END
) duration
from film
order by title;



select segment, count(segment)
from (select (
CASE
    WHEN rental_rate = 0.99 THEN 'ECONOMY'
    WHEN rental_rate = 2.99 THEN 'MASS'
    WHEN rental_rate = 4.99 THEN 'PREMIUM'
END
) segment from film) as segments
group by segment
order by segment;


select SUM(CASE rental_rate
          WHEN 0.99 THEN 1
          ELSE 0
          END) Economy,
          SUM(CASE rental_rate
             WHEN 2.99 THEN 1
             ELSE 0
             END) as Mass,
          SUM(CASE rental_rate
             WHEN 4.99 THEN 1
             ELSE 0
             END) as Premium
from film;


SELECT title,
       rating,
       CASE rating
           WHEN 'G' THEN 'General Audiences'
           WHEN 'PG' THEN 'Parental Guidance Suggested'
           WHEN 'PG-13' THEN 'Parents Strongly Cautioned'
           WHEN 'R' THEN 'Restricted'
           WHEN 'NC-17' THEN 'Adults Only'
       END rating_description
FROM film
ORDER BY title;



select Coalesce(NULL, NULL, 4, 2, 5);
select Coalesce(NULL, NULL);


CREATE TABLE items ( ID serial PRIMARY KEY, product VARCHAR (100) NOT NULL, price NUMERIC NOT NULL, discount NUMERIC );

INSERT INTO items (product, price, discount) VALUES ('A', 1000 ,10), ('B', 1500 ,20), ('C', 800 ,5), ('D', 500, NULL);

select product, (price - discount) as net_price
from items;


select product, (price - coalesce(discount, 0)) as net_price
from items;

-- NULLIF
-- IF both arguments equal then return null
-- else return arg1

select NULLIF(10, 10);

select NULLIF(10, 5);


CREATE TABLE sales_target ( salesperson_id integer NOT NULL, salesperson character varying(255) NOT NULL, store_state character varying(255) NOT NULL, sales_target numeric NOT NULL, sales_current numeric NOT NULL );

INSERT INTO sales_target (salesperson_id ,salesperson ,store_state ,sales_target ,sales_current) VALUES (101,'Danish K','KA',10000,10000), (102,'Rashmi Sharma','DL',23000,18000), (103,'Mohak Patel','MH',21000,21000), (104,'Devika Ramaswamy','TN',10000,8000), (105,'Reema Ray','WB',0,10000);



select * from sales_target;

select COALESCE(NULLIF(sales_target, sales_current), sales_target) - sales_current
from sales_target;

select sales_target - sales_current
from sales_target;


select '23-02-1999'::date;
select cast('23-02-1999' as date);


-- Data types
-- Boolean

select true = 't', true = 'yes', true = 'y', true = '1';
select false = 'f', false = 'no', false = 'n', false = '0';

-- numeric(p, s)
-- p = total digits
-- s = number of digits after decimal
-- this follows p > s and p != s 
select 131.01222323::numeric(3,1);



SELECT a, b, c,
            a + b,
            a + b = c
        FROM (
        SELECT 0.1::float8 a, 0.2::float8 b, 0.3::float8 c) AS t;
        
        
SELECT a, b, c,
            a + b,
            a + b = c
        FROM (
        SELECT 0.1::numeric a, 0.2::numeric b, 0.3::numeric c) AS t;   
        
        
-- SMALLINT: 2 bytes ~ 2^(16- 1) - 1 
-- INTEGER: 4 bytes
-- BIGINT: 8 bytes


select 21289382::BIGINT;

-- Date: 4 bytes

select now()::date;
select CURRENT_DATE;

select to_char(now()::date, 'dd mm yyyy');
select to_char(now()::date, 'Day, mm yyyy');
select to_char(now()::date, 'Day, dd yyyy');

-- Difference of dates in days
select 'My Age: ' || now()::date - '23-02-1999'::date;
-- Difference in years, months and days
select age('23-02-1999'::date);
-- first date - second date in the same format
select age('01-01-2015'::date,'23-02-1999'::date);

select extract (month from now()::date);


-- Time: 8 bytes, precision up to 6 digits
-- Time(precision)

select current_time(2);

-- extracting hours, minutes, and seconds

select extract (hour from current_time);
select extract (minute from current_time);
select extract (second from current_time);


select current_time at time zone 'GMT+0';

select current_time + interval '3 hours';
select current_time + '3 hours'::interval;

select '11:00'::time - '3:00'::time;

-- timestamp: 8 bytes: date + time
select timeofday();

show timezone;
select timezone('America/New_York', now());

select (now() - '2 years 2 months'::interval)::date;

-- UUID
create extension if not exists "uuid-ossp";

select uuid_generate_v4();


CREATE TABLE contacts (
    contact_id uuid DEFAULT uuid_generate_v4 (),
    first_name VARCHAR NOT NULL);
    
INSERT INTO contacts (first_name)
VALUES 
    ( 'ABC');
    
select * from contacts;    

-- JSON
CREATE TABLE restaurent_orders ( ID serial NOT NULL PRIMARY KEY, info json NOT NULL );
INSERT INTO restaurent_orders(info) VALUES ( '{ "customer": "Shaheed Kapoor", "items": {"product": "coffee", "qty": 6}}' );
select * from restaurent_orders;

-- hstore: Key-value pairs
create extension hstore;

CREATE TABLE bank_employee (
    id serial primary key,
    name VARCHAR (255),
    data hstore
    );

insert into bank_employee(name, data)
values ('Anthony', '"contact_number" => "9912002430", "salary" => "30000"');

select * from bank_employee;
select data->'salary' from bank_employee;

select name, data->'contact_number' as contact
from bank_employee
where data->'salary' < '50000';

-- update hstore
update bank_employee
set data = data || hstore('hobby', 'Indoor Activity')
where id = 1;

update bank_employee
set data = data || '"roll_number" => "1234567"'::hstore
where id = 1;

-- delete key-value pair
update bank_employee
set data = delete(data, 'roll_number')
where id = 1;

-- fetch all keys in one row
select akeys(data) from bank_employee;
-- fetch all keys in one column
select skeys(data) from bank_employee;


-- fetch all values in one row
select avals(data) from bank_employee;
-- fetch all values in one column
select svals(data) from bank_employee;


-- convert to json
select hstore_to_json(data) as json_data
from bank_employee;

-- convert to sets
select each(data) from bank_employee;
select (each(data)).* from bank_employee;


-- array (indexing starts from 1)
select '{"1", "2", "3"}';


CREATE TABLE contact ( id serial PRIMARY KEY, name VARCHAR (100), phones TEXT [] );

INSERT INTO contact (name, phones) 
VALUES ( 'Raju Kumar', '{"(408)-589-5841"}' ), 
( 'Nikhil Aggarwal', '{"(408)-589-5841"}' ), 
( 'Anshul Aggarwal', '{"(408)-589-5841"}' ), 
( 'Puja Singh', '{"(408)-589-5842", "(408)-589-58423"}' );

select * from contact;

select name
from contact
where name ilike any('{"n%", "p%"}');

select name, phones[2]
from contact;

update contact set phones[2] = '{"(202)-5555-444","(105)-777-5555"}' where name='Raju Kumar';

-- Domain - user defined types : normal types + check statement (constraint)


create domain dom_day as int constraint check_bound check(value > 0 and value <= 31);

create table dummy(
id serial primary key,
name text,
birth_day dom_day
);

insert into dummy (name, birth_day)
values ('Abhishek', 23);

insert into dummy (name, birth_day)
values ('XYZ', 50);


-- TYPES
-- Step 1: Create a type
CREATE TYPE film_summary1 AS (
    film_id INT,
    title VARCHAR,
    rel_year SMALLINT
); 
-- Step 2 return type as the return type of a function
CREATE OR REPLACE FUNCTION get_film_summary1 (f_id INT) 
    RETURNS film_summary1 AS 
$$ 
SELECT
    film_id,
    title,
    release_year
FROM
    film
WHERE
    film_id = f_id ; 
$$ 
LANGUAGE SQL;

select release_year from get_film_summary(40);

create sequence my_seq
start 10
increment 2
maxvalue 20
minvalue 10
cycle;

drop sequence if exists my_seq;


select nextval('my_seq');


select * from contact;

select * into new_contact from contact;
select * from new_contact;


select * into new_film from film where Rating = 'R' and rental_duration = 5;

select * from action_film_1;

CREATE TABLE action_film_1 AS SELECT film_id, title, release_year from film where rating = 'R' AND rental_duration = 5;

create temp table if not exists mytemp();

create unlogged table t_unlogged();


-- SERIES
select generate_series(10, 20) as ser;

select ('01-01-2022'::date + (generate_series(0, 11) * '1 month'::interval))::date;

select generate_series('01-01-2022'::date, '01-10-2022'::date, '1 month')::date;



